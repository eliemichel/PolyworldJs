<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf8" />
		<title>Polyworld</title>
		<link href="css/style.css" type="text/css" rel="stylesheet" />
	</head>

	<body>
		<script id="injectAfterCommon" type="x-shader/x-vertex">

			/**
			 * A tree is composed of a stacking of "floors" (either trunk or foilage elements)
			 */
			struct TreeConfig {
				uint crownFloorCount;
				float height;
				float crownRandomness;
				float crownBaseRadius;
				float crownShrinkFactor;
				float trunkHeight;
				float trunkRadius;
				float trunkRandomness;
				vec3 trunkColor;
				vec3 crownColors[4];
				vec3 bend;
			};

			/**
			 * Trees from a family are all the possible interpolations between 'presetCount' different presets.
			 */
			struct TreeFamilyConfig {
				TreeConfig presets[2];
				uint presetCount;
			};

			TreeConfig mixTreeConfig(TreeConfig a, TreeConfig b, float fac) {
				return TreeConfig(
					uint(mix(float(a.crownFloorCount), float(b.crownFloorCount), fac)),
					mix(a.height, b.height, fac),
					mix(a.crownRandomness, b.crownRandomness, fac),
					mix(a.crownBaseRadius, b.crownBaseRadius, fac),
					mix(a.crownShrinkFactor, b.crownShrinkFactor, fac),
					mix(a.trunkHeight, b.trunkHeight, fac),
					mix(a.trunkRadius, b.trunkRadius, fac),
					mix(a.trunkRandomness, b.trunkRandomness, fac),
					mix(a.trunkColor, b.trunkColor, vec3(fac)),
					vec3[4](
						mix(a.crownColors[0], b.crownColors[0], vec3(fac)),
						mix(a.crownColors[1], b.crownColors[1], vec3(fac)),
						mix(a.crownColors[2], b.crownColors[2], vec3(fac)),
						mix(a.crownColors[3], b.crownColors[3], vec3(fac))
					),
					mix(a.bend, b.bend, vec3(fac))
				);
			}

			/**
			 * Config for a given floor, extracted from the tree config and floor index
			 */
			 struct TreeFloorConfig {
				vec3 color;
				float height;
				float bottomRadius;
				float topRadius;
				float randomness;

				// Sum of all previous floor's height
				float offset;
			};

			TreeFloorConfig getFloorConfig(TreeConfig config, uint floorIndex) {
				bool isTrunk = floorIndex == 0u;
				bool isHidden = floorIndex > config.crownFloorCount;
				if (isTrunk) {
					return TreeFloorConfig(
						config.trunkColor,
						config.trunkHeight,
						config.trunkRadius,
						config.trunkRadius,
						config.trunkRandomness,
						0.0
					);
				} else if (!isHidden) {
					uint crownIndex = floorIndex - 1u;
					float crownBottomFac = float(crownIndex) / float(config.crownFloorCount);
					float crownTopFac = float(crownIndex + 1u) / float(config.crownFloorCount);
					uint colorIndex = uint(crownBottomFac * 4.0);
					float crownHeight = config.height - config.trunkHeight;
					return TreeFloorConfig(
						config.crownColors[colorIndex],
						crownHeight / float(config.crownFloorCount),
						mix(config.crownBaseRadius, 0.0, crownBottomFac),
						mix(config.crownBaseRadius, 0.0, crownTopFac) * config.crownShrinkFactor,
						config.crownRandomness,
						config.trunkHeight + crownBottomFac * crownHeight
					);
				} else {
					return TreeFloorConfig(
						vec3(0.0),
						0.0,
						0.0,
						0.0,
						0.0,
						0.0
					);
				}
			}

			uniform float time;
			uniform float noiseLevel;
			uniform TreeFamilyConfig treeFamilyConfig;

			attribute float radius;
			attribute vec2 height;
			attribute uint floorIndex;

			float rand31(vec3 seed1, float seed2) {
				return rand(vec2(
					rand(seed1.xy),
					rand(vec2(seed1.z, seed2))
				));
			}

		</script>

		<script id="injectAfterColorVertex" type="x-shader/x-vertex">

			TreeConfig configA = treeFamilyConfig.presets[0];
			TreeConfig configB = treeFamilyConfig.presets[1];
			float instanceFac = (float(gl_InstanceID) + 0.5) / float(10);
			TreeConfig config = mixTreeConfig(configA, configB, instanceFac);

			TreeFloorConfig floorConfig = getFloorConfig(config, floorIndex);

			vColor.rgb = floorConfig.color;
			vColor *= mix(1.0, 0.5, position.y);

		</script>

		<script id="injectAfterBeginVertex" type="x-shader/x-vertex">

			// Radius
			float radius = mix(floorConfig.bottomRadius, floorConfig.topRadius, position.y);
			float radiusFac = length(position.xz);
			transformed.xz *= radiusFac * radius;

			// Instance transformation
			transformed.x += float(gl_InstanceID) * 3.0;

			transformed.y *= floorConfig.height;
			transformed.y += floorConfig.offset;

			// Noise
			vec3 offset = vec3(
				rand31(transformed.xyz, 0.5 / 3.0),
				rand31(transformed.xyz, 1.5 / 3.0),
				rand31(transformed.xyz, 2.5 / 3.0)
			) - 0.5;
			transformed.xyz += normalize(offset) * noiseLevel * radius;

		</script>

		<script type="importmap">
		{
			"imports": {
				"three": "./third_party/three.module.min.js",
				"three/addons/": "./third_party/three/addons/"
			}
		}
		</script>
		<script type="module" src="js/main.js"></script>
	</body>
</html>
